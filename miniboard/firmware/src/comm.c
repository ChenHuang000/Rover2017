/* OSU Robotics Club Rover 2016
 * Miniboard Firmware
 * 
 * comm.c - Non-autogenerated portion of the communication module.
 *          This works with the commgen.c/.h files to implement the 
 *          computer control interface.
 * Author(s): Nick Ames
 */
#include <avr/interrupt.h>
#include <stdbool.h>
#define F_CPU 16000000UL
#include "uart.h"
#include "commgen.h"
#include "comm.h"

#define PACKET_BUF_SIZE 150
#define BAUD TODO
#define START_BYTE 0x01
#define ESC_BYTE 0x02
#define END_BYTE 0x03

/* Configure the computer communications uart. */
void comm_init(void){
	//TODO: Configure uart
}

/* Receive a byte and place it in the packet buffer.
 * This function handles start, escape, and end bytes.
 * It calls the parse_packet() function when an end byte
 * is received. */
void comm_receive_byte(uint8_t byte){
	static uint8_t pbuf[PACKET_BUF_SIZE];
	static uint16_t pcount; /* Number of bytes in packet buffer. */
	static bool escape; /* The last byte received was an escape byte. */
	static bool badpack; /* An overflow occured, so ignore the next end byte. */
	
	if((byte == START_BYTE|| byte == ESC_BYTE || byte == END_BYTE) && !escape){
		/* Handle special characters. */
		if(byte == START_BYTE){
			pcount = 0;
			badpack = false;
		} else if(byte == ESC_BYTE){
			escape = true;
		} else if(byte == END_BYTE){
			if(!badpack){
				parse_packet(pbuf, pcount);
				pcount = 0;
			} else {
				pcount = 0;
			}
		}
	} else {
		escape = false;
		if(pcount < PACKET_BUF_SIZE){
			pbuf[pcount] = byte;
			pcount++;
		} else {
			badpack = true;
		}
	}
}

void (*UART0RXHandler)(uint8_t) = comm_receive_byte;